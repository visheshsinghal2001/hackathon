/// <reference types="node" />
/**
 * Metered license consumption information
 */
export declare class ConsumptionResult {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
    /**
     * Amount of used credits
     */
    credit: number;
    /**
     * Amount of MBs processed
     */
    quantity: number;
    constructor(init?: Partial<ConsumptionResult>);
}
/**
 * Class for disc space information.
 */
export declare class DiscUsage {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
    /**
     * Application used disc space.
     */
    usedSize: number;
    /**
     * Total disc space.
     */
    totalSize: number;
    constructor(init?: Partial<DiscUsage>);
}
/**
 * Describes document result
 */
export declare class DocumentResult {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
    /**
     * Path of the output document
     */
    path: string;
    constructor(init?: Partial<DocumentResult>);
}
/**
 * The error details
 */
export declare class ErrorDetails {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
    /**
     * The request id
     */
    requestId: string;
    /**
     * Date
     */
    date: Date;
    constructor(init?: Partial<ErrorDetails>);
}
/**
 * Describes file properties
 */
export declare class FileInfo {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
    /**
     * File path in storage
     */
    filePath: string;
    /**
     * Storage name
     */
    storageName: string;
    /**
     * Version ID
     */
    versionId: string;
    /**
     * Password to open file
     */
    password: string;
    constructor(init?: Partial<FileInfo>);
}
/**
 * File versions FileVersion.
 */
export declare class FileVersions {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
    /**
     * File versions FileVersion.
     */
    value: Array<FileVersion>;
    constructor(init?: Partial<FileVersions>);
}
/**
 * Files list
 */
export declare class FilesList {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
    /**
     * Files and folders contained by folder StorageFile.
     */
    value: Array<StorageFile>;
    constructor(init?: Partial<FilesList>);
}
/**
 * File upload result
 */
export declare class FilesUploadResult {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
    /**
     * List of uploaded file names
     */
    uploaded: Array<string>;
    /**
     * List of errors.
     */
    errors: Array<Error>;
    constructor(init?: Partial<FilesUploadResult>);
}
/**
 * Describes file format properties
 */
export declare class Format {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
    /**
     * File extension
     */
    extension: string;
    /**
     * File format
     */
    fileFormat: string;
    constructor(init?: Partial<Format>);
}
/**
 * Describes object which contains list of supported file formats.
 */
export declare class FormatsResult {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
    /**
     * Supported file formats.
     */
    formats: Array<Format>;
    constructor(init?: Partial<FormatsResult>);
}
/**
 * Describes document properties result
 */
export declare class InfoResult {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
    /**
     * Pages count
     */
    pageCount: number;
    /**
     * Document size in bytes
     */
    size: number;
    /**
     * Indicates whether specific file is encrypted and requires password for opening.
     */
    isEncrypted: boolean;
    /**
     * File format
     */
    fileFormat: string;
    /**
     * Document extension
     */
    extension: string;
    constructor(init?: Partial<InfoResult>);
}
/**
 * Describes load result
 */
export declare class LoadResult {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
    /**
     * Path of the editable document
     */
    htmlPath: string;
    /**
     * Path of the document resources
     */
    resourcesPath: string;
    constructor(init?: Partial<LoadResult>);
}
/**
 * Error
 */
export declare class ModelError {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
    /**
     * Code
     */
    code: string;
    /**
     * Message
     */
    message: string;
    /**
     * Description
     */
    description: string;
    /**
     * Inner Error
     */
    innerError: ErrorDetails;
    constructor(init?: Partial<ModelError>);
}
/**
 * Object exists
 */
export declare class ObjectExist {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
    /**
     * Indicates that the file or folder exists.
     */
    exists: boolean;
    /**
     * True if it is a folder, false if it is a file.
     */
    isFolder: boolean;
    constructor(init?: Partial<ObjectExist>);
}
/**
 * Describes basic options properties
 */
export declare class Options {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
    /**
     * File info
     */
    fileInfo: FileInfo;
    /**
     * The full output path
     */
    outputPath: string;
    constructor(init?: Partial<Options>);
}
/**
 * Storage exists
 */
export declare class StorageExist {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
    /**
     * Shows that the storage exists.
     */
    exists: boolean;
    constructor(init?: Partial<StorageExist>);
}
/**
 * File or folder information
 */
export declare class StorageFile {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
    /**
     * File or folder name.
     */
    name: string;
    /**
     * True if it is a folder.
     */
    isFolder: boolean;
    /**
     * File or folder last modified DateTime.
     */
    modifiedDate: Date;
    /**
     * File or folder size.
     */
    size: number;
    /**
     * File or folder path.
     */
    path: string;
    constructor(init?: Partial<StorageFile>);
}
/**
 * File Version
 */
export declare class FileVersion extends StorageFile {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
    /**
     * File Version ID.
     */
    versionId: string;
    /**
     * Specifies whether the file is (true) or is not (false) the latest version of an file.
     */
    isLatest: boolean;
    constructor(init?: Partial<FileVersion>);
}
/**
 * Options for loading documents
 */
export declare class LoadOptions extends Options {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
    constructor(init?: Partial<LoadOptions>);
}
/**
 * Save options
 */
export declare class SaveOptions extends Options {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
    /**
     * The Html document path
     */
    htmlPath: string;
    /**
     * Resources path
     */
    resourcesPath: string;
    /**
     * Document format
     */
    format: string;
    constructor(init?: Partial<SaveOptions>);
}
/**
 * Options for loading text-based Spreadsheet documents (CSV, Tab-based etc.), that use a separator (delimiter)
 */
export declare class DelimitedTextLoadOptions extends LoadOptions {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
    /**
     * Allows to specify a string separator (delimiter) for text-based Spreadsheet documents
     */
    separator: string;
    /**
     * Gets or sets a value that indicates whether the string in text-based document is converted to the date data. Default is false.
     */
    convertDateTimeData: boolean;
    /**
     * Gets or sets a value that indicates whether the string in text-based document is converted to numeric data. Default is false.
     */
    convertNumericData: boolean;
    /**
     * Defines whether consecutive delimiters should be treated as one. By default is false.
     */
    treatConsecutiveDelimitersAsOne: boolean;
    constructor(init?: Partial<DelimitedTextLoadOptions>);
}
/**
 * Contains options for generating and saving text-based Spreadsheet documents (CSV, Tab-based etc.), that use a separator (delimiter)
 */
export declare class DelimitedTextSaveOptions extends SaveOptions {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
    /**
     * Allows to specify a string separator (delimiter) for text-based Spreadsheet documents
     */
    separator: string;
    /**
     * Allows to set an encoding for the text-based Spreadsheet document. By default (and if not specified) is UTF-8.
     */
    encoding: string;
    /**
     * Indicates whether leading blank rows and columns should be trimmed like what MS Excel does
     */
    trimLeadingBlankRowAndColumn: boolean;
    /**
     * Indicates whether separators should be output for blank row. Default value is false which means the content for blank row will be empty.
     */
    keepSeparatorsForBlankRow: boolean;
    constructor(init?: Partial<DelimitedTextSaveOptions>);
}
/**
 * Allows to specify custom options for generating and saving PDF (Portable Document Format) documents
 */
export declare class PdfSaveOptions extends SaveOptions {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
    /**
     * Password, which will be applied to the generated PDF document as user password, required for opening. If NULL or empty, no password will be applied to the document. Otherwise, document will be encrypted with RC4 (key length of 128 bit).
     */
    password: string;
    /**
     * Specifies the PDF standards compliance level for output documents. Default is PdfCompliance.Pdf15.
     */
    compliance: PdfSaveOptions.ComplianceEnum;
    constructor(init?: Partial<PdfSaveOptions>);
}
export declare namespace PdfSaveOptions {
    enum ComplianceEnum {
        Pdf15,
        PdfA1a,
        PdfA1b
    }
}
/**
 * Allows to specify custom options for editing documents of all supportable Presentation (PowerPoint-compatible) formats
 */
export declare class PresentationLoadOptions extends LoadOptions {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
    /**
     * Allows to specify the slide number, which should be opened for editing
     */
    slideNumber: number;
    /**
     * Specifies whether the hidden slides should be included or not. Default is false     - hidden slides are not shown and exception will be thrown while trying to edit
     */
    showHiddenSlides: boolean;
    constructor(init?: Partial<PresentationLoadOptions>);
}
/**
 * Allows to specify custom options for generating and saving Presentation (PowerPoint-compatible) documents
 */
export declare class PresentationSaveOptions extends SaveOptions {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
    /**
     * Allows to specify document password
     */
    password: string;
    constructor(init?: Partial<PresentationSaveOptions>);
}
/**
 * Allows to specify custom options for editing documents of all supportable Spreadsheet (Excel-compatible) formats
 */
export declare class SpreadsheetLoadOptions extends LoadOptions {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
    /**
     * Allows to specify the 0-based index of the worksheet (tab) of the input Spreadsheet document, which should be converted to the HTML.
     */
    worksheetIndex: number;
    /**
     * Allows to exclude hidden worksheets in the input Spreadsheet document, so they will be totally ignored. Default is false - hidden worksheets are available and processed as normal.
     */
    excludeHiddenWorksheets: boolean;
    constructor(init?: Partial<SpreadsheetLoadOptions>);
}
/**
 * Allows to specify custom options for generating and saving Spreadsheet (Excel-compliant) documents
 */
export declare class SpreadsheetSaveOptions extends SaveOptions {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
    /**
     * Allows to specify document password
     */
    password: string;
    /**
     * Write-protection type. Default value is None.
     */
    protectionType: SpreadsheetSaveOptions.ProtectionTypeEnum;
    /**
     * Write-protection password. Used when protection type is specified.
     */
    protectionPassword: string;
    constructor(init?: Partial<SpreadsheetSaveOptions>);
}
export declare namespace SpreadsheetSaveOptions {
    enum ProtectionTypeEnum {
        None,
        All,
        Contents,
        Objects,
        Scenarios,
        Structure,
        Window
    }
}
/**
 * Allows to specify custom options for loading plain text (TXT) documents
 */
export declare class TextLoadOptions extends LoadOptions {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
    /**
     * Character encoding of the text document, which will be applied for its opening
     */
    encoding: string;
    /**
     * Allows to specify how numbered list items are recognized when document is imported from plain text format. The default value is true.
     */
    recognizeLists: boolean;
    /**
     * Gets or sets preferred option of a leading space handling. By default converts leading spaces to the left indent.
     */
    leadingSpaces: TextLoadOptions.LeadingSpacesEnum;
    /**
     * Gets or sets preferred option of a trailing space handling. By default truncates all trailing spaces.
     */
    trailingSpaces: TextLoadOptions.TrailingSpacesEnum;
    /**
     * Allows to enable or disable pagination in the resultant HTML document. By default is disabled (false).
     */
    enablePagination: boolean;
    constructor(init?: Partial<TextLoadOptions>);
}
export declare namespace TextLoadOptions {
    enum LeadingSpacesEnum {
        ConvertToIndent,
        Preserve,
        Trim
    }
    enum TrailingSpacesEnum {
        Trim,
        Preserve
    }
}
/**
 * Allows to specify custom options for generating and saving plain text (TXT) documents
 */
export declare class TextSaveOptions extends SaveOptions {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
    /**
     * Character encoding of the text document, which will be applied for its saving
     */
    encoding: string;
    /**
     * Specifies whether to add bi-directional marks before each BiDi run when exporting in plain text format
     */
    addBidiMarks: boolean;
    /**
     * Specifies whether the program should attempt to preserve layout of tables when saving in the plain text format. The default value is false.
     */
    preserveTableLayout: boolean;
    constructor(init?: Partial<TextSaveOptions>);
}
/**
 * Allows to specify custom options for loading WordProcessing-compliant documents
 */
export declare class WordProcessingLoadOptions extends LoadOptions {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
    /**
     * Allows to enable or disable pagination in the resultant HTML document. By default is disabled (false).
     */
    enablePagination: boolean;
    /**
     * Specifies whether language information is exported to the HTML markup in a form of 'lang' HTML attributes. This option may be useful for roundtrip conversion of the multi-language documents. By default it is disabled (false).
     */
    enableLanguageInformation: boolean;
    /**
     * Responsible for extracting font resources, which are used in the input WordProcessing document. By default doesn't extract any fonts (NotExtract).
     */
    fontExtraction: WordProcessingLoadOptions.FontExtractionEnum;
    constructor(init?: Partial<WordProcessingLoadOptions>);
}
export declare namespace WordProcessingLoadOptions {
    enum FontExtractionEnum {
        NotExtract,
        ExtractAllEmbedded,
        ExtractEmbeddedWithoutSystem,
        ExtractAll
    }
}
/**
 * Allows to specify custom options for generating and saving WordProcessing-compliant documents
 */
export declare class WordProcessingSaveOptions extends SaveOptions {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
    /**
     * Allows to specify document password
     */
    password: string;
    /**
     * Allows to enable or disable pagination which will be used for saving the document. If the original document was opened and edited in pagination mode, this option also should be enabled. By default is disabled.
     */
    enablePagination: boolean;
    /**
     * Allows to set override default locale (language) for the WordProcessing document, which will be applied during its creation. When is not specified (default value), MS Word (or other program) will detect (or choose) the document locale according to its own settings or other factors.
     */
    locale: string;
    /**
     * Allows to set override locale (language) for the WordProcessing document for the RTL (right-to-left) text, which will be applied during its creation. When is not specified (default value), MS Word (or other program) will detect (or choose) the document RTL locale according to its own settings or other factors.
     */
    localeBi: string;
    /**
     * Allows to override the locale (language) for the WordProcessing document for the East-Asian text, which will be applied during its creation. When is not specified (default value), MS Word (or other program) will detect (or choose) the document East-Asian locale according to its own settings or other factors.
     */
    localeFarEast: string;
    /**
     * Write-protection type. Default value is NoProtection
     */
    protectionType: WordProcessingSaveOptions.ProtectionTypeEnum;
    /**
     * Write-protection password. Used when protection type is specified.
     */
    protectionPassword: string;
    constructor(init?: Partial<WordProcessingSaveOptions>);
}
export declare namespace WordProcessingSaveOptions {
    enum ProtectionTypeEnum {
        NoProtection,
        AllowOnlyRevisions,
        AllowOnlyComments,
        AllowOnlyFormFields,
        ReadOnly
    }
}
/**
 * Allows to specify custom options for loading XML (eXtensible Markup Language) documents
 */
export declare class XmlLoadOptions extends LoadOptions {
    /**
     * Attribute type map
     */
    static attributeTypeMap: Array<{
        name: string;
        baseName: string;
        type: string;
    }>;
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap(): {
        name: string;
        baseName: string;
        type: string;
    }[];
    /**
     * Character encoding of the text document, which will be applied for its opening. By default is null - internal document encoding will be applied.
     */
    encoding: string;
    /**
     * Allows to enable or disable mechanism for fixing corrupted XML structure. By default is disabled (false).
     */
    fixIncorrectStructure: boolean;
    /**
     * Allows to enable URI recognition algorithm
     */
    recognizeUris: boolean;
    /**
     * Allows to enable recognition algorithm for email addresses in attribute values
     */
    recognizeEmails: boolean;
    /**
     * Allows to enable the truncation of trailing whitespaces in the inner-tag text. By default is disabled (false) - trailing whitespaces will be preserved.
     */
    trimTrailingWhitespaces: boolean;
    /**
     * Allows to specify quote type (single or double quotes) for attribute values. Double quotes are default.
     */
    attributeValuesQuoteType: XmlLoadOptions.AttributeValuesQuoteTypeEnum;
    constructor(init?: Partial<XmlLoadOptions>);
}
export declare namespace XmlLoadOptions {
    enum AttributeValuesQuoteTypeEnum {
        DoubleQuote,
        SingleQuote
    }
}
declare const enumsMap: {
    "PdfSaveOptions.ComplianceEnum": typeof PdfSaveOptions.ComplianceEnum;
    "SpreadsheetSaveOptions.ProtectionTypeEnum": typeof SpreadsheetSaveOptions.ProtectionTypeEnum;
    "TextLoadOptions.LeadingSpacesEnum": typeof TextLoadOptions.LeadingSpacesEnum;
    "TextLoadOptions.TrailingSpacesEnum": typeof TextLoadOptions.TrailingSpacesEnum;
    "WordProcessingLoadOptions.FontExtractionEnum": typeof WordProcessingLoadOptions.FontExtractionEnum;
    "WordProcessingSaveOptions.ProtectionTypeEnum": typeof WordProcessingSaveOptions.ProtectionTypeEnum;
    "XmlLoadOptions.AttributeValuesQuoteTypeEnum": typeof XmlLoadOptions.AttributeValuesQuoteTypeEnum;
};
declare const typeMap: {
    ConsumptionResult: typeof ConsumptionResult;
    DiscUsage: typeof DiscUsage;
    DocumentResult: typeof DocumentResult;
    ErrorDetails: typeof ErrorDetails;
    FileInfo: typeof FileInfo;
    FileVersions: typeof FileVersions;
    FilesList: typeof FilesList;
    FilesUploadResult: typeof FilesUploadResult;
    Format: typeof Format;
    FormatsResult: typeof FormatsResult;
    InfoResult: typeof InfoResult;
    LoadResult: typeof LoadResult;
    ModelError: typeof ModelError;
    ObjectExist: typeof ObjectExist;
    Options: typeof Options;
    StorageExist: typeof StorageExist;
    StorageFile: typeof StorageFile;
    FileVersion: typeof FileVersion;
    LoadOptions: typeof LoadOptions;
    SaveOptions: typeof SaveOptions;
    DelimitedTextLoadOptions: typeof DelimitedTextLoadOptions;
    DelimitedTextSaveOptions: typeof DelimitedTextSaveOptions;
    PdfSaveOptions: typeof PdfSaveOptions;
    PresentationLoadOptions: typeof PresentationLoadOptions;
    PresentationSaveOptions: typeof PresentationSaveOptions;
    SpreadsheetLoadOptions: typeof SpreadsheetLoadOptions;
    SpreadsheetSaveOptions: typeof SpreadsheetSaveOptions;
    TextLoadOptions: typeof TextLoadOptions;
    TextSaveOptions: typeof TextSaveOptions;
    WordProcessingLoadOptions: typeof WordProcessingLoadOptions;
    WordProcessingSaveOptions: typeof WordProcessingSaveOptions;
    XmlLoadOptions: typeof XmlLoadOptions;
};
export { enumsMap, typeMap };
/**
 * Request model for Load operation.
 */
export declare class LoadRequest {
    /**
     * The document load options
     */
    loadOptions: LoadOptions;
    constructor(loadOptions: LoadOptions);
}
/**
 * Request model for Save operation.
 */
export declare class SaveRequest {
    /**
     * Edited document save options
     */
    saveOptions: SaveOptions;
    constructor(saveOptions: SaveOptions);
}
/**
 * Request model for CopyFile operation.
 */
export declare class CopyFileRequest {
    /**
     * Source file path e.g. '/folder/file.ext'
     */
    srcPath: string;
    /**
     * Destination file path
     */
    destPath: string;
    /**
     * Source storage name
     */
    srcStorageName: string;
    /**
     * Destination storage name
     */
    destStorageName: string;
    /**
     * File version ID to copy
     */
    versionId: string;
    constructor(srcPath: string, destPath: string, srcStorageName?: string, destStorageName?: string, versionId?: string);
}
/**
 * Request model for DeleteFile operation.
 */
export declare class DeleteFileRequest {
    /**
     * File path e.g. '/folder/file.ext'
     */
    path: string;
    /**
     * Storage name
     */
    storageName: string;
    /**
     * File version ID to delete
     */
    versionId: string;
    constructor(path: string, storageName?: string, versionId?: string);
}
/**
 * Request model for DownloadFile operation.
 */
export declare class DownloadFileRequest {
    /**
     * File path e.g. '/folder/file.ext'
     */
    path: string;
    /**
     * Storage name
     */
    storageName: string;
    /**
     * File version ID to download
     */
    versionId: string;
    constructor(path: string, storageName?: string, versionId?: string);
}
/**
 * Request model for MoveFile operation.
 */
export declare class MoveFileRequest {
    /**
     * Source file path e.g. '/src.ext'
     */
    srcPath: string;
    /**
     * Destination file path e.g. '/dest.ext'
     */
    destPath: string;
    /**
     * Source storage name
     */
    srcStorageName: string;
    /**
     * Destination storage name
     */
    destStorageName: string;
    /**
     * File version ID to move
     */
    versionId: string;
    constructor(srcPath: string, destPath: string, srcStorageName?: string, destStorageName?: string, versionId?: string);
}
/**
 * Request model for UploadFile operation.
 */
export declare class UploadFileRequest {
    /**
     * Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext             If the content is multipart and path does not contains the file name it tries to get them from filename parameter             from Content-Disposition header.
     */
    path: string;
    /**
     * File to upload
     */
    file: Buffer;
    /**
     * Storage name
     */
    storageName: string;
    constructor(path: string, file: Buffer, storageName?: string);
}
/**
 * Request model for CopyFolder operation.
 */
export declare class CopyFolderRequest {
    /**
     * Source folder path e.g. '/src'
     */
    srcPath: string;
    /**
     * Destination folder path e.g. '/dst'
     */
    destPath: string;
    /**
     * Source storage name
     */
    srcStorageName: string;
    /**
     * Destination storage name
     */
    destStorageName: string;
    constructor(srcPath: string, destPath: string, srcStorageName?: string, destStorageName?: string);
}
/**
 * Request model for CreateFolder operation.
 */
export declare class CreateFolderRequest {
    /**
     * Folder path to create e.g. 'folder_1/folder_2/'
     */
    path: string;
    /**
     * Storage name
     */
    storageName: string;
    constructor(path: string, storageName?: string);
}
/**
 * Request model for DeleteFolder operation.
 */
export declare class DeleteFolderRequest {
    /**
     * Folder path e.g. '/folder'
     */
    path: string;
    /**
     * Storage name
     */
    storageName: string;
    /**
     * Enable to delete folders, subfolders and files
     */
    recursive: boolean;
    constructor(path: string, storageName?: string, recursive?: boolean);
}
/**
 * Request model for GetFilesList operation.
 */
export declare class GetFilesListRequest {
    /**
     * Folder path e.g. '/folder'
     */
    path: string;
    /**
     * Storage name
     */
    storageName: string;
    constructor(path: string, storageName?: string);
}
/**
 * Request model for MoveFolder operation.
 */
export declare class MoveFolderRequest {
    /**
     * Folder path to move e.g. '/folder'
     */
    srcPath: string;
    /**
     * Destination folder path to move to e.g '/dst'
     */
    destPath: string;
    /**
     * Source storage name
     */
    srcStorageName: string;
    /**
     * Destination storage name
     */
    destStorageName: string;
    constructor(srcPath: string, destPath: string, srcStorageName?: string, destStorageName?: string);
}
/**
 * Request model for GetInfo operation.
 */
export declare class GetInfoRequest {
    /**
     * File Info
     */
    fileInfo: FileInfo;
    constructor(fileInfo: FileInfo);
}
/**
 * Request model for GetDiscUsage operation.
 */
export declare class GetDiscUsageRequest {
    /**
     * Storage name
     */
    storageName: string;
    constructor(storageName?: string);
}
/**
 * Request model for GetFileVersions operation.
 */
export declare class GetFileVersionsRequest {
    /**
     * File path e.g. '/file.ext'
     */
    path: string;
    /**
     * Storage name
     */
    storageName: string;
    constructor(path: string, storageName?: string);
}
/**
 * Request model for ObjectExists operation.
 */
export declare class ObjectExistsRequest {
    /**
     * File or folder path e.g. '/file.ext' or '/folder'
     */
    path: string;
    /**
     * Storage name
     */
    storageName: string;
    /**
     * File version ID
     */
    versionId: string;
    constructor(path: string, storageName?: string, versionId?: string);
}
/**
 * Request model for StorageExists operation.
 */
export declare class StorageExistsRequest {
    /**
     * Storage name
     */
    storageName: string;
    constructor(storageName: string);
}
