"use strict";
/*
* The MIT License (MIT)
*
* Copyright (c) 2003-2022 Aspose Pty Ltd
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*/
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Metered license consumption information
 */
class ConsumptionResult {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return ConsumptionResult.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
ConsumptionResult.attributeTypeMap = [
    {
        name: "credit",
        baseName: "credit",
        type: "number",
    },
    {
        name: "quantity",
        baseName: "quantity",
        type: "number",
    }
];
exports.ConsumptionResult = ConsumptionResult;
/**
 * Class for disc space information.
 */
class DiscUsage {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return DiscUsage.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
DiscUsage.attributeTypeMap = [
    {
        name: "usedSize",
        baseName: "usedSize",
        type: "number",
    },
    {
        name: "totalSize",
        baseName: "totalSize",
        type: "number",
    }
];
exports.DiscUsage = DiscUsage;
/**
 * Describes document result
 */
class DocumentResult {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return DocumentResult.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
DocumentResult.attributeTypeMap = [
    {
        name: "path",
        baseName: "path",
        type: "string",
    }
];
exports.DocumentResult = DocumentResult;
/**
 * The error details
 */
class ErrorDetails {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return ErrorDetails.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
ErrorDetails.attributeTypeMap = [
    {
        name: "requestId",
        baseName: "requestId",
        type: "string",
    },
    {
        name: "date",
        baseName: "date",
        type: "Date",
    }
];
exports.ErrorDetails = ErrorDetails;
/**
 * Describes file properties
 */
class FileInfo {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return FileInfo.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
FileInfo.attributeTypeMap = [
    {
        name: "filePath",
        baseName: "filePath",
        type: "string",
    },
    {
        name: "storageName",
        baseName: "storageName",
        type: "string",
    },
    {
        name: "versionId",
        baseName: "versionId",
        type: "string",
    },
    {
        name: "password",
        baseName: "password",
        type: "string",
    }
];
exports.FileInfo = FileInfo;
/**
 * File versions FileVersion.
 */
class FileVersions {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return FileVersions.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
FileVersions.attributeTypeMap = [
    {
        name: "value",
        baseName: "value",
        type: "Array<FileVersion>",
    }
];
exports.FileVersions = FileVersions;
/**
 * Files list
 */
class FilesList {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return FilesList.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
FilesList.attributeTypeMap = [
    {
        name: "value",
        baseName: "value",
        type: "Array<StorageFile>",
    }
];
exports.FilesList = FilesList;
/**
 * File upload result
 */
class FilesUploadResult {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return FilesUploadResult.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
FilesUploadResult.attributeTypeMap = [
    {
        name: "uploaded",
        baseName: "uploaded",
        type: "Array<string>",
    },
    {
        name: "errors",
        baseName: "errors",
        type: "Array<Error>",
    }
];
exports.FilesUploadResult = FilesUploadResult;
/**
 * Describes file format properties
 */
class Format {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return Format.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
Format.attributeTypeMap = [
    {
        name: "extension",
        baseName: "extension",
        type: "string",
    },
    {
        name: "fileFormat",
        baseName: "fileFormat",
        type: "string",
    }
];
exports.Format = Format;
/**
 * Describes object which contains list of supported file formats.
 */
class FormatsResult {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return FormatsResult.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
FormatsResult.attributeTypeMap = [
    {
        name: "formats",
        baseName: "formats",
        type: "Array<Format>",
    }
];
exports.FormatsResult = FormatsResult;
/**
 * Describes document properties result
 */
class InfoResult {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return InfoResult.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
InfoResult.attributeTypeMap = [
    {
        name: "pageCount",
        baseName: "pageCount",
        type: "number",
    },
    {
        name: "size",
        baseName: "size",
        type: "number",
    },
    {
        name: "isEncrypted",
        baseName: "isEncrypted",
        type: "boolean",
    },
    {
        name: "fileFormat",
        baseName: "fileFormat",
        type: "string",
    },
    {
        name: "extension",
        baseName: "extension",
        type: "string",
    }
];
exports.InfoResult = InfoResult;
/**
 * Describes load result
 */
class LoadResult {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return LoadResult.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
LoadResult.attributeTypeMap = [
    {
        name: "htmlPath",
        baseName: "htmlPath",
        type: "string",
    },
    {
        name: "resourcesPath",
        baseName: "resourcesPath",
        type: "string",
    }
];
exports.LoadResult = LoadResult;
/**
 * Error
 */
class ModelError {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return ModelError.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
ModelError.attributeTypeMap = [
    {
        name: "code",
        baseName: "code",
        type: "string",
    },
    {
        name: "message",
        baseName: "message",
        type: "string",
    },
    {
        name: "description",
        baseName: "description",
        type: "string",
    },
    {
        name: "innerError",
        baseName: "innerError",
        type: "ErrorDetails",
    }
];
exports.ModelError = ModelError;
/**
 * Object exists
 */
class ObjectExist {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return ObjectExist.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
ObjectExist.attributeTypeMap = [
    {
        name: "exists",
        baseName: "exists",
        type: "boolean",
    },
    {
        name: "isFolder",
        baseName: "isFolder",
        type: "boolean",
    }
];
exports.ObjectExist = ObjectExist;
/**
 * Describes basic options properties
 */
class Options {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return Options.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
Options.attributeTypeMap = [
    {
        name: "fileInfo",
        baseName: "fileInfo",
        type: "FileInfo",
    },
    {
        name: "outputPath",
        baseName: "outputPath",
        type: "string",
    }
];
exports.Options = Options;
/**
 * Storage exists
 */
class StorageExist {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return StorageExist.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
StorageExist.attributeTypeMap = [
    {
        name: "exists",
        baseName: "exists",
        type: "boolean",
    }
];
exports.StorageExist = StorageExist;
/**
 * File or folder information
 */
class StorageFile {
    constructor(init) {
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return StorageFile.attributeTypeMap;
    }
}
/**
 * Attribute type map
 */
StorageFile.attributeTypeMap = [
    {
        name: "name",
        baseName: "name",
        type: "string",
    },
    {
        name: "isFolder",
        baseName: "isFolder",
        type: "boolean",
    },
    {
        name: "modifiedDate",
        baseName: "modifiedDate",
        type: "Date",
    },
    {
        name: "size",
        baseName: "size",
        type: "number",
    },
    {
        name: "path",
        baseName: "path",
        type: "string",
    }
];
exports.StorageFile = StorageFile;
/**
 * File Version
 */
class FileVersion extends StorageFile {
    constructor(init) {
        super(init);
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(FileVersion.attributeTypeMap);
    }
}
/**
 * Attribute type map
 */
FileVersion.attributeTypeMap = [
    {
        name: "versionId",
        baseName: "versionId",
        type: "string",
    },
    {
        name: "isLatest",
        baseName: "isLatest",
        type: "boolean",
    }
];
exports.FileVersion = FileVersion;
/**
 * Options for loading documents
 */
class LoadOptions extends Options {
    constructor(init) {
        super(init);
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(LoadOptions.attributeTypeMap);
    }
}
/**
 * Attribute type map
 */
LoadOptions.attributeTypeMap = [];
exports.LoadOptions = LoadOptions;
/**
 * Save options
 */
class SaveOptions extends Options {
    constructor(init) {
        super(init);
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SaveOptions.attributeTypeMap);
    }
}
/**
 * Attribute type map
 */
SaveOptions.attributeTypeMap = [
    {
        name: "htmlPath",
        baseName: "htmlPath",
        type: "string",
    },
    {
        name: "resourcesPath",
        baseName: "resourcesPath",
        type: "string",
    },
    {
        name: "format",
        baseName: "format",
        type: "string",
    }
];
exports.SaveOptions = SaveOptions;
/**
 * Options for loading text-based Spreadsheet documents (CSV, Tab-based etc.), that use a separator (delimiter)
 */
class DelimitedTextLoadOptions extends LoadOptions {
    constructor(init) {
        super(init);
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(DelimitedTextLoadOptions.attributeTypeMap);
    }
}
/**
 * Attribute type map
 */
DelimitedTextLoadOptions.attributeTypeMap = [
    {
        name: "separator",
        baseName: "separator",
        type: "string",
    },
    {
        name: "convertDateTimeData",
        baseName: "convertDateTimeData",
        type: "boolean",
    },
    {
        name: "convertNumericData",
        baseName: "convertNumericData",
        type: "boolean",
    },
    {
        name: "treatConsecutiveDelimitersAsOne",
        baseName: "treatConsecutiveDelimitersAsOne",
        type: "boolean",
    }
];
exports.DelimitedTextLoadOptions = DelimitedTextLoadOptions;
/**
 * Contains options for generating and saving text-based Spreadsheet documents (CSV, Tab-based etc.), that use a separator (delimiter)
 */
class DelimitedTextSaveOptions extends SaveOptions {
    constructor(init) {
        super(init);
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(DelimitedTextSaveOptions.attributeTypeMap);
    }
}
/**
 * Attribute type map
 */
DelimitedTextSaveOptions.attributeTypeMap = [
    {
        name: "separator",
        baseName: "separator",
        type: "string",
    },
    {
        name: "encoding",
        baseName: "encoding",
        type: "string",
    },
    {
        name: "trimLeadingBlankRowAndColumn",
        baseName: "trimLeadingBlankRowAndColumn",
        type: "boolean",
    },
    {
        name: "keepSeparatorsForBlankRow",
        baseName: "keepSeparatorsForBlankRow",
        type: "boolean",
    }
];
exports.DelimitedTextSaveOptions = DelimitedTextSaveOptions;
/**
 * Allows to specify custom options for generating and saving PDF (Portable Document Format) documents
 */
class PdfSaveOptions extends SaveOptions {
    constructor(init) {
        super(init);
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PdfSaveOptions.attributeTypeMap);
    }
}
/**
 * Attribute type map
 */
PdfSaveOptions.attributeTypeMap = [
    {
        name: "password",
        baseName: "password",
        type: "string",
    },
    {
        name: "compliance",
        baseName: "compliance",
        type: "PdfSaveOptions.ComplianceEnum",
    }
];
exports.PdfSaveOptions = PdfSaveOptions;
// tslint:disable:quotemark
// tslint:disable-next-line:no-namespace
(function (PdfSaveOptions) {
    let ComplianceEnum;
    (function (ComplianceEnum) {
        ComplianceEnum[ComplianceEnum["Pdf15"] = 'Pdf15'] = "Pdf15";
        ComplianceEnum[ComplianceEnum["PdfA1a"] = 'PdfA1a'] = "PdfA1a";
        ComplianceEnum[ComplianceEnum["PdfA1b"] = 'PdfA1b'] = "PdfA1b";
    })(ComplianceEnum = PdfSaveOptions.ComplianceEnum || (PdfSaveOptions.ComplianceEnum = {}));
})(PdfSaveOptions = exports.PdfSaveOptions || (exports.PdfSaveOptions = {}));
// tslint:enable:quotemark
/**
 * Allows to specify custom options for editing documents of all supportable Presentation (PowerPoint-compatible) formats
 */
class PresentationLoadOptions extends LoadOptions {
    constructor(init) {
        super(init);
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PresentationLoadOptions.attributeTypeMap);
    }
}
/**
 * Attribute type map
 */
PresentationLoadOptions.attributeTypeMap = [
    {
        name: "slideNumber",
        baseName: "slideNumber",
        type: "number",
    },
    {
        name: "showHiddenSlides",
        baseName: "showHiddenSlides",
        type: "boolean",
    }
];
exports.PresentationLoadOptions = PresentationLoadOptions;
/**
 * Allows to specify custom options for generating and saving Presentation (PowerPoint-compatible) documents
 */
class PresentationSaveOptions extends SaveOptions {
    constructor(init) {
        super(init);
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PresentationSaveOptions.attributeTypeMap);
    }
}
/**
 * Attribute type map
 */
PresentationSaveOptions.attributeTypeMap = [
    {
        name: "password",
        baseName: "password",
        type: "string",
    }
];
exports.PresentationSaveOptions = PresentationSaveOptions;
/**
 * Allows to specify custom options for editing documents of all supportable Spreadsheet (Excel-compatible) formats
 */
class SpreadsheetLoadOptions extends LoadOptions {
    constructor(init) {
        super(init);
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SpreadsheetLoadOptions.attributeTypeMap);
    }
}
/**
 * Attribute type map
 */
SpreadsheetLoadOptions.attributeTypeMap = [
    {
        name: "worksheetIndex",
        baseName: "worksheetIndex",
        type: "number",
    },
    {
        name: "excludeHiddenWorksheets",
        baseName: "excludeHiddenWorksheets",
        type: "boolean",
    }
];
exports.SpreadsheetLoadOptions = SpreadsheetLoadOptions;
/**
 * Allows to specify custom options for generating and saving Spreadsheet (Excel-compliant) documents
 */
class SpreadsheetSaveOptions extends SaveOptions {
    constructor(init) {
        super(init);
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SpreadsheetSaveOptions.attributeTypeMap);
    }
}
/**
 * Attribute type map
 */
SpreadsheetSaveOptions.attributeTypeMap = [
    {
        name: "password",
        baseName: "password",
        type: "string",
    },
    {
        name: "protectionType",
        baseName: "protectionType",
        type: "SpreadsheetSaveOptions.ProtectionTypeEnum",
    },
    {
        name: "protectionPassword",
        baseName: "protectionPassword",
        type: "string",
    }
];
exports.SpreadsheetSaveOptions = SpreadsheetSaveOptions;
// tslint:disable:quotemark
// tslint:disable-next-line:no-namespace
(function (SpreadsheetSaveOptions) {
    let ProtectionTypeEnum;
    (function (ProtectionTypeEnum) {
        ProtectionTypeEnum[ProtectionTypeEnum["None"] = 'None'] = "None";
        ProtectionTypeEnum[ProtectionTypeEnum["All"] = 'All'] = "All";
        ProtectionTypeEnum[ProtectionTypeEnum["Contents"] = 'Contents'] = "Contents";
        ProtectionTypeEnum[ProtectionTypeEnum["Objects"] = 'Objects'] = "Objects";
        ProtectionTypeEnum[ProtectionTypeEnum["Scenarios"] = 'Scenarios'] = "Scenarios";
        ProtectionTypeEnum[ProtectionTypeEnum["Structure"] = 'Structure'] = "Structure";
        ProtectionTypeEnum[ProtectionTypeEnum["Window"] = 'Window'] = "Window";
    })(ProtectionTypeEnum = SpreadsheetSaveOptions.ProtectionTypeEnum || (SpreadsheetSaveOptions.ProtectionTypeEnum = {}));
})(SpreadsheetSaveOptions = exports.SpreadsheetSaveOptions || (exports.SpreadsheetSaveOptions = {}));
// tslint:enable:quotemark
/**
 * Allows to specify custom options for loading plain text (TXT) documents
 */
class TextLoadOptions extends LoadOptions {
    constructor(init) {
        super(init);
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TextLoadOptions.attributeTypeMap);
    }
}
/**
 * Attribute type map
 */
TextLoadOptions.attributeTypeMap = [
    {
        name: "encoding",
        baseName: "encoding",
        type: "string",
    },
    {
        name: "recognizeLists",
        baseName: "recognizeLists",
        type: "boolean",
    },
    {
        name: "leadingSpaces",
        baseName: "leadingSpaces",
        type: "TextLoadOptions.LeadingSpacesEnum",
    },
    {
        name: "trailingSpaces",
        baseName: "trailingSpaces",
        type: "TextLoadOptions.TrailingSpacesEnum",
    },
    {
        name: "enablePagination",
        baseName: "enablePagination",
        type: "boolean",
    }
];
exports.TextLoadOptions = TextLoadOptions;
// tslint:disable:quotemark
// tslint:disable-next-line:no-namespace
(function (TextLoadOptions) {
    let LeadingSpacesEnum;
    (function (LeadingSpacesEnum) {
        LeadingSpacesEnum[LeadingSpacesEnum["ConvertToIndent"] = 'ConvertToIndent'] = "ConvertToIndent";
        LeadingSpacesEnum[LeadingSpacesEnum["Preserve"] = 'Preserve'] = "Preserve";
        LeadingSpacesEnum[LeadingSpacesEnum["Trim"] = 'Trim'] = "Trim";
    })(LeadingSpacesEnum = TextLoadOptions.LeadingSpacesEnum || (TextLoadOptions.LeadingSpacesEnum = {}));
    let TrailingSpacesEnum;
    (function (TrailingSpacesEnum) {
        TrailingSpacesEnum[TrailingSpacesEnum["Trim"] = 'Trim'] = "Trim";
        TrailingSpacesEnum[TrailingSpacesEnum["Preserve"] = 'Preserve'] = "Preserve";
    })(TrailingSpacesEnum = TextLoadOptions.TrailingSpacesEnum || (TextLoadOptions.TrailingSpacesEnum = {}));
})(TextLoadOptions = exports.TextLoadOptions || (exports.TextLoadOptions = {}));
// tslint:enable:quotemark
/**
 * Allows to specify custom options for generating and saving plain text (TXT) documents
 */
class TextSaveOptions extends SaveOptions {
    constructor(init) {
        super(init);
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TextSaveOptions.attributeTypeMap);
    }
}
/**
 * Attribute type map
 */
TextSaveOptions.attributeTypeMap = [
    {
        name: "encoding",
        baseName: "encoding",
        type: "string",
    },
    {
        name: "addBidiMarks",
        baseName: "addBidiMarks",
        type: "boolean",
    },
    {
        name: "preserveTableLayout",
        baseName: "preserveTableLayout",
        type: "boolean",
    }
];
exports.TextSaveOptions = TextSaveOptions;
/**
 * Allows to specify custom options for loading WordProcessing-compliant documents
 */
class WordProcessingLoadOptions extends LoadOptions {
    constructor(init) {
        super(init);
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(WordProcessingLoadOptions.attributeTypeMap);
    }
}
/**
 * Attribute type map
 */
WordProcessingLoadOptions.attributeTypeMap = [
    {
        name: "enablePagination",
        baseName: "enablePagination",
        type: "boolean",
    },
    {
        name: "enableLanguageInformation",
        baseName: "enableLanguageInformation",
        type: "boolean",
    },
    {
        name: "fontExtraction",
        baseName: "fontExtraction",
        type: "WordProcessingLoadOptions.FontExtractionEnum",
    }
];
exports.WordProcessingLoadOptions = WordProcessingLoadOptions;
// tslint:disable:quotemark
// tslint:disable-next-line:no-namespace
(function (WordProcessingLoadOptions) {
    let FontExtractionEnum;
    (function (FontExtractionEnum) {
        FontExtractionEnum[FontExtractionEnum["NotExtract"] = 'NotExtract'] = "NotExtract";
        FontExtractionEnum[FontExtractionEnum["ExtractAllEmbedded"] = 'ExtractAllEmbedded'] = "ExtractAllEmbedded";
        FontExtractionEnum[FontExtractionEnum["ExtractEmbeddedWithoutSystem"] = 'ExtractEmbeddedWithoutSystem'] = "ExtractEmbeddedWithoutSystem";
        FontExtractionEnum[FontExtractionEnum["ExtractAll"] = 'ExtractAll'] = "ExtractAll";
    })(FontExtractionEnum = WordProcessingLoadOptions.FontExtractionEnum || (WordProcessingLoadOptions.FontExtractionEnum = {}));
})(WordProcessingLoadOptions = exports.WordProcessingLoadOptions || (exports.WordProcessingLoadOptions = {}));
// tslint:enable:quotemark
/**
 * Allows to specify custom options for generating and saving WordProcessing-compliant documents
 */
class WordProcessingSaveOptions extends SaveOptions {
    constructor(init) {
        super(init);
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(WordProcessingSaveOptions.attributeTypeMap);
    }
}
/**
 * Attribute type map
 */
WordProcessingSaveOptions.attributeTypeMap = [
    {
        name: "password",
        baseName: "password",
        type: "string",
    },
    {
        name: "enablePagination",
        baseName: "enablePagination",
        type: "boolean",
    },
    {
        name: "locale",
        baseName: "locale",
        type: "string",
    },
    {
        name: "localeBi",
        baseName: "localeBi",
        type: "string",
    },
    {
        name: "localeFarEast",
        baseName: "localeFarEast",
        type: "string",
    },
    {
        name: "protectionType",
        baseName: "protectionType",
        type: "WordProcessingSaveOptions.ProtectionTypeEnum",
    },
    {
        name: "protectionPassword",
        baseName: "protectionPassword",
        type: "string",
    }
];
exports.WordProcessingSaveOptions = WordProcessingSaveOptions;
// tslint:disable:quotemark
// tslint:disable-next-line:no-namespace
(function (WordProcessingSaveOptions) {
    let ProtectionTypeEnum;
    (function (ProtectionTypeEnum) {
        ProtectionTypeEnum[ProtectionTypeEnum["NoProtection"] = 'NoProtection'] = "NoProtection";
        ProtectionTypeEnum[ProtectionTypeEnum["AllowOnlyRevisions"] = 'AllowOnlyRevisions'] = "AllowOnlyRevisions";
        ProtectionTypeEnum[ProtectionTypeEnum["AllowOnlyComments"] = 'AllowOnlyComments'] = "AllowOnlyComments";
        ProtectionTypeEnum[ProtectionTypeEnum["AllowOnlyFormFields"] = 'AllowOnlyFormFields'] = "AllowOnlyFormFields";
        ProtectionTypeEnum[ProtectionTypeEnum["ReadOnly"] = 'ReadOnly'] = "ReadOnly";
    })(ProtectionTypeEnum = WordProcessingSaveOptions.ProtectionTypeEnum || (WordProcessingSaveOptions.ProtectionTypeEnum = {}));
})(WordProcessingSaveOptions = exports.WordProcessingSaveOptions || (exports.WordProcessingSaveOptions = {}));
// tslint:enable:quotemark
/**
 * Allows to specify custom options for loading XML (eXtensible Markup Language) documents
 */
class XmlLoadOptions extends LoadOptions {
    constructor(init) {
        super(init);
        Object.assign(this, init);
    }
    /**
     * Returns attribute type map
     */
    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(XmlLoadOptions.attributeTypeMap);
    }
}
/**
 * Attribute type map
 */
XmlLoadOptions.attributeTypeMap = [
    {
        name: "encoding",
        baseName: "encoding",
        type: "string",
    },
    {
        name: "fixIncorrectStructure",
        baseName: "fixIncorrectStructure",
        type: "boolean",
    },
    {
        name: "recognizeUris",
        baseName: "recognizeUris",
        type: "boolean",
    },
    {
        name: "recognizeEmails",
        baseName: "recognizeEmails",
        type: "boolean",
    },
    {
        name: "trimTrailingWhitespaces",
        baseName: "trimTrailingWhitespaces",
        type: "boolean",
    },
    {
        name: "attributeValuesQuoteType",
        baseName: "attributeValuesQuoteType",
        type: "XmlLoadOptions.AttributeValuesQuoteTypeEnum",
    }
];
exports.XmlLoadOptions = XmlLoadOptions;
// tslint:disable:quotemark
// tslint:disable-next-line:no-namespace
(function (XmlLoadOptions) {
    let AttributeValuesQuoteTypeEnum;
    (function (AttributeValuesQuoteTypeEnum) {
        AttributeValuesQuoteTypeEnum[AttributeValuesQuoteTypeEnum["DoubleQuote"] = 'DoubleQuote'] = "DoubleQuote";
        AttributeValuesQuoteTypeEnum[AttributeValuesQuoteTypeEnum["SingleQuote"] = 'SingleQuote'] = "SingleQuote";
    })(AttributeValuesQuoteTypeEnum = XmlLoadOptions.AttributeValuesQuoteTypeEnum || (XmlLoadOptions.AttributeValuesQuoteTypeEnum = {}));
})(XmlLoadOptions = exports.XmlLoadOptions || (exports.XmlLoadOptions = {}));
// tslint:enable:quotemark
const enumsMap = {
    "PdfSaveOptions.ComplianceEnum": PdfSaveOptions.ComplianceEnum,
    "SpreadsheetSaveOptions.ProtectionTypeEnum": SpreadsheetSaveOptions.ProtectionTypeEnum,
    "TextLoadOptions.LeadingSpacesEnum": TextLoadOptions.LeadingSpacesEnum,
    "TextLoadOptions.TrailingSpacesEnum": TextLoadOptions.TrailingSpacesEnum,
    "WordProcessingLoadOptions.FontExtractionEnum": WordProcessingLoadOptions.FontExtractionEnum,
    "WordProcessingSaveOptions.ProtectionTypeEnum": WordProcessingSaveOptions.ProtectionTypeEnum,
    "XmlLoadOptions.AttributeValuesQuoteTypeEnum": XmlLoadOptions.AttributeValuesQuoteTypeEnum,
};
exports.enumsMap = enumsMap;
const typeMap = {
    ConsumptionResult,
    DiscUsage,
    DocumentResult,
    ErrorDetails,
    FileInfo,
    FileVersions,
    FilesList,
    FilesUploadResult,
    Format,
    FormatsResult,
    InfoResult,
    LoadResult,
    ModelError,
    ObjectExist,
    Options,
    StorageExist,
    StorageFile,
    FileVersion,
    LoadOptions,
    SaveOptions,
    DelimitedTextLoadOptions,
    DelimitedTextSaveOptions,
    PdfSaveOptions,
    PresentationLoadOptions,
    PresentationSaveOptions,
    SpreadsheetLoadOptions,
    SpreadsheetSaveOptions,
    TextLoadOptions,
    TextSaveOptions,
    WordProcessingLoadOptions,
    WordProcessingSaveOptions,
    XmlLoadOptions,
};
exports.typeMap = typeMap;
/**
 * Request model for Load operation.
 */
class LoadRequest {
    constructor(loadOptions) {
        this.loadOptions = loadOptions;
    }
}
exports.LoadRequest = LoadRequest;
/**
 * Request model for Save operation.
 */
class SaveRequest {
    constructor(saveOptions) {
        this.saveOptions = saveOptions;
    }
}
exports.SaveRequest = SaveRequest;
/**
 * Request model for CopyFile operation.
 */
class CopyFileRequest {
    constructor(srcPath, destPath, srcStorageName, destStorageName, versionId) {
        this.srcPath = srcPath;
        this.destPath = destPath;
        this.srcStorageName = srcStorageName;
        this.destStorageName = destStorageName;
        this.versionId = versionId;
    }
}
exports.CopyFileRequest = CopyFileRequest;
/**
 * Request model for DeleteFile operation.
 */
class DeleteFileRequest {
    constructor(path, storageName, versionId) {
        this.path = path;
        this.storageName = storageName;
        this.versionId = versionId;
    }
}
exports.DeleteFileRequest = DeleteFileRequest;
/**
 * Request model for DownloadFile operation.
 */
class DownloadFileRequest {
    constructor(path, storageName, versionId) {
        this.path = path;
        this.storageName = storageName;
        this.versionId = versionId;
    }
}
exports.DownloadFileRequest = DownloadFileRequest;
/**
 * Request model for MoveFile operation.
 */
class MoveFileRequest {
    constructor(srcPath, destPath, srcStorageName, destStorageName, versionId) {
        this.srcPath = srcPath;
        this.destPath = destPath;
        this.srcStorageName = srcStorageName;
        this.destStorageName = destStorageName;
        this.versionId = versionId;
    }
}
exports.MoveFileRequest = MoveFileRequest;
/**
 * Request model for UploadFile operation.
 */
class UploadFileRequest {
    constructor(path, file, storageName) {
        this.path = path;
        this.file = file;
        this.storageName = storageName;
    }
}
exports.UploadFileRequest = UploadFileRequest;
/**
 * Request model for CopyFolder operation.
 */
class CopyFolderRequest {
    constructor(srcPath, destPath, srcStorageName, destStorageName) {
        this.srcPath = srcPath;
        this.destPath = destPath;
        this.srcStorageName = srcStorageName;
        this.destStorageName = destStorageName;
    }
}
exports.CopyFolderRequest = CopyFolderRequest;
/**
 * Request model for CreateFolder operation.
 */
class CreateFolderRequest {
    constructor(path, storageName) {
        this.path = path;
        this.storageName = storageName;
    }
}
exports.CreateFolderRequest = CreateFolderRequest;
/**
 * Request model for DeleteFolder operation.
 */
class DeleteFolderRequest {
    constructor(path, storageName, recursive) {
        this.path = path;
        this.storageName = storageName;
        this.recursive = recursive;
    }
}
exports.DeleteFolderRequest = DeleteFolderRequest;
/**
 * Request model for GetFilesList operation.
 */
class GetFilesListRequest {
    constructor(path, storageName) {
        this.path = path;
        this.storageName = storageName;
    }
}
exports.GetFilesListRequest = GetFilesListRequest;
/**
 * Request model for MoveFolder operation.
 */
class MoveFolderRequest {
    constructor(srcPath, destPath, srcStorageName, destStorageName) {
        this.srcPath = srcPath;
        this.destPath = destPath;
        this.srcStorageName = srcStorageName;
        this.destStorageName = destStorageName;
    }
}
exports.MoveFolderRequest = MoveFolderRequest;
/**
 * Request model for GetInfo operation.
 */
class GetInfoRequest {
    constructor(fileInfo) {
        this.fileInfo = fileInfo;
    }
}
exports.GetInfoRequest = GetInfoRequest;
/**
 * Request model for GetDiscUsage operation.
 */
class GetDiscUsageRequest {
    constructor(storageName) {
        this.storageName = storageName;
    }
}
exports.GetDiscUsageRequest = GetDiscUsageRequest;
/**
 * Request model for GetFileVersions operation.
 */
class GetFileVersionsRequest {
    constructor(path, storageName) {
        this.path = path;
        this.storageName = storageName;
    }
}
exports.GetFileVersionsRequest = GetFileVersionsRequest;
/**
 * Request model for ObjectExists operation.
 */
class ObjectExistsRequest {
    constructor(path, storageName, versionId) {
        this.path = path;
        this.storageName = storageName;
        this.versionId = versionId;
    }
}
exports.ObjectExistsRequest = ObjectExistsRequest;
/**
 * Request model for StorageExists operation.
 */
class StorageExistsRequest {
    constructor(storageName) {
        this.storageName = storageName;
    }
}
exports.StorageExistsRequest = StorageExistsRequest;
